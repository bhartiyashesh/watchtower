---
phase: 01-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - config.py
  - .env.example
  - event_store.py
  - thumbnails/.gitkeep
autonomous: true
requirements: [DATA-01, DATA-02, DATA-03, DATA-04, DATA-05, DATA-06]

must_haves:
  truths:
    - "A motion event record can be written to SQLite and read back with all fields intact"
    - "YOLO detection results can be stored linked to an event and retrieved by event_id"
    - "A JPEG thumbnail is saved to thumbnails/ directory and its path stored in event record"
    - "An unlock action is logged with person name, confidence, distance, and success status"
    - "WAL mode is active on the database connection"
    - "Face recognition results (person name, distance, confidence) are stored per event"
  artifacts:
    - path: "event_store.py"
      provides: "Complete EventStore class with async CRUD, WAL mode, schema creation"
      exports: ["EventStore"]
    - path: "config.py"
      provides: "DB_PATH and THUMBNAILS_DIR configuration variables"
      contains: "DB_PATH"
    - path: "requirements.txt"
      provides: "aiosqlite and aiofiles dependencies"
      contains: "aiosqlite"
    - path: "thumbnails/.gitkeep"
      provides: "Thumbnail storage directory"
  key_links:
    - from: "event_store.py"
      to: "config.py"
      via: "DB_PATH and THUMBNAILS_DIR env vars"
      pattern: "Config\\.DB_PATH|Config\\.THUMBNAILS_DIR"
    - from: "event_store.py"
      to: "aiosqlite"
      via: "aiosqlite.connect() with WAL mode"
      pattern: "aiosqlite\\.connect"
    - from: "event_store.py"
      to: "thumbnails/"
      via: "Pillow JPEG save to thumbnails directory"
      pattern: "img\\.save.*JPEG"
---

<objective>
Create the EventStore module — the single database interface for the entire system. This module wraps an aiosqlite connection in WAL mode, creates the full schema (events, detections, persons tables with indexes), provides async write/read methods for events and detections, and saves thumbnails as JPEG files on disk.

Purpose: Every downstream phase (object detection, pipeline integration, Telegram alerts, web dashboard) depends on structured event storage existing and working correctly. This is the dependency root for the entire project.

Output: Working `event_store.py` module, updated `config.py` with DB/thumbnail paths, updated `requirements.txt`, and `thumbnails/` directory ready for JPEG files.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@config.py
@requirements.txt
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and update config</name>
  <files>requirements.txt, config.py, .env.example, thumbnails/.gitkeep</files>
  <action>
1. Add `aiosqlite==0.22.1` and `aiofiles==24.1.0` to `requirements.txt` (append after existing entries). Then run `pip install -r requirements.txt` inside the existing venv.

2. Add two new class attributes to `Config` in `config.py`:
   ```python
   DB_PATH: str = os.getenv("DB_PATH", "./events.db")
   THUMBNAILS_DIR: str = os.getenv("THUMBNAILS_DIR", "./thumbnails")
   ```
   Place them after the "Timing" section, under a new `# Storage` comment block.

3. Add these lines to `.env.example` at the bottom, under a `# Storage (Phase 1)` header:
   ```
   # Storage (Phase 1: Data Foundation)
   DB_PATH=./events.db
   THUMBNAILS_DIR=./thumbnails
   # Production (Raspberry Pi): point to USB SSD
   # DB_PATH=/mnt/usb/events.db
   # THUMBNAILS_DIR=/mnt/usb/thumbnails
   ```

4. Create `thumbnails/.gitkeep` (empty file) so the directory is tracked by git.

5. Run `pip check` after install to confirm no dependency conflicts (especially numpy between ultralytics and opencv-python, and httpx if any transitive deps).
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && source venv/bin/activate && python -c "import aiosqlite; print(f'aiosqlite {aiosqlite.__version__}')" && python -c "import aiofiles; print('aiofiles OK')" && python -c "from config import Config; assert hasattr(Config, 'DB_PATH'); assert hasattr(Config, 'THUMBNAILS_DIR'); print('Config OK')" && test -d thumbnails && echo "thumbnails dir OK"</automated>
  </verify>
  <done>aiosqlite and aiofiles importable in venv. Config.DB_PATH and Config.THUMBNAILS_DIR exist with correct defaults. thumbnails/ directory exists. pip check reports no conflicts.</done>
</task>

<task type="auto">
  <name>Task 2: Implement EventStore module with full schema and CRUD</name>
  <files>event_store.py</files>
  <action>
Create `event_store.py` in the project root. This is the complete database interface for the system.

**Class: EventStore**

Constructor `__init__(self, db_path: str, thumbnails_dir: str = "thumbnails")`:
- Store `db_path` as string and `thumbnails_dir` as `Path` object.
- Initialize `self.db: aiosqlite.Connection | None = None`.

**Method: `async def initialize(self) -> None`**
- Create thumbnails directory: `self.thumbnails_dir.mkdir(parents=True, exist_ok=True)`
- Open connection: `self.db = await aiosqlite.connect(self.db_path)`
- Set `self.db.row_factory = aiosqlite.Row`
- Execute PRAGMAs in this exact order (BEFORE any DDL):
  1. `PRAGMA journal_mode=WAL`
  2. `PRAGMA foreign_keys=ON`
  3. `PRAGMA busy_timeout=5000`
  4. `PRAGMA synchronous=NORMAL`
  5. `await self.db.commit()`
- Create three tables using `CREATE TABLE IF NOT EXISTS`:

  **events table:**
  - `id INTEGER PRIMARY KEY AUTOINCREMENT`
  - `camera_id TEXT NOT NULL DEFAULT 'front_door'`
  - `recorded_at TEXT NOT NULL` (ISO 8601 UTC)
  - `event_type TEXT NOT NULL DEFAULT 'motion'` (values: 'motion', 'ding')
  - `recording_id TEXT` (nullable — Ring recording ID)
  - `person_name TEXT` (NULL=stranger, non-NULL=recognized person name)
  - `face_confidence REAL` (derived: `max(0.0, 1.0 - face_distance)`)
  - `face_distance REAL` (raw euclidean distance from face_recognition)
  - `unlock_granted INTEGER NOT NULL DEFAULT 0` (boolean: 1=unlocked, 0=not)
  - `door_action TEXT DEFAULT 'none'` (values: 'unlocked', 'locked', 'none')
  - `thumbnail_path TEXT` (relative path: 'thumbnails/2026-02-25T10-30-00.jpg')
  - `alert_sent INTEGER NOT NULL DEFAULT 0` (boolean: 1=Telegram alert sent)
  - `created_at TEXT NOT NULL DEFAULT (datetime('now'))`

  **detections table:**
  - `id INTEGER PRIMARY KEY AUTOINCREMENT`
  - `event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE`
  - `label TEXT NOT NULL` ('person', 'dog', 'cat', 'car', 'package')
  - `confidence REAL NOT NULL` (YOLO confidence 0.0-1.0)
  - `bbox_x1 REAL, bbox_y1 REAL, bbox_x2 REAL, bbox_y2 REAL` (nullable bounding box pixel coords)

  **persons table:**
  - `id INTEGER PRIMARY KEY AUTOINCREMENT`
  - `name TEXT NOT NULL UNIQUE` (matches known_faces/ directory prefix)
  - `display_name TEXT`
  - `created_at TEXT NOT NULL DEFAULT (datetime('now'))`

- Create indexes:
  - `idx_events_recorded_at ON events(recorded_at DESC)`
  - `idx_events_camera_id ON events(camera_id)`
  - `idx_events_person_name ON events(person_name)`
  - `idx_detections_event_id ON detections(event_id)`
  - `idx_detections_label ON detections(label)`

- Commit after all DDL.

**Method: `def save_thumbnail(self, frame_bytes: bytes, event_timestamp: str) -> str | None`**
- Synchronous method (thumbnail save is CPU-bound Pillow work, called before DB write).
- Sanitize timestamp for filename: replace ":" with "-" and "." with "-".
- Construct filename: `{safe_ts}.jpg`
- Construct path: `self.thumbnails_dir / filename`
- Open frame_bytes with `PIL.Image.open(io.BytesIO(frame_bytes))`.
- Save as JPEG with quality=85: `img.save(str(path), "JPEG", quality=85)`
- Return the relative path string (e.g., `"thumbnails/2026-02-25T10-30-00.jpg"`).
- Wrap in try/except and return None on any error (thumbnail failure must never fail event storage).
- Log errors with `logging.getLogger(__name__)`.

**Method: `async def write_event(self, ...) -> int`**
- Parameters: `camera_id: str`, `recorded_at: str`, `recording_id: str | None = None`, `event_type: str = "motion"`, `person_name: str | None = None`, `face_confidence: float | None = None`, `face_distance: float | None = None`, `unlock_granted: bool = False`, `door_action: str = "none"`, `thumbnail_path: str | None = None`, `detections: list[dict] | None = None`
- INSERT into events table, get `cursor.lastrowid` as `event_id`.
- If detections provided, use `executemany` to INSERT all detection rows with the `event_id` FK.
- Each detection dict has keys: `label`, `confidence`, and optional `bbox_x1`, `bbox_y1`, `bbox_x2`, `bbox_y2`.
- `await self.db.commit()` after both inserts (atomic transaction).
- Return `event_id`.

**Method: `async def get_event(self, event_id: int) -> dict | None`**
- SELECT * from events WHERE id = event_id.
- If not found, return None.
- SELECT * from detections WHERE event_id = event_id.
- Return dict with all event fields plus `"detections": [list of detection dicts]`.

**Method: `async def get_recent_events(self, limit: int = 20, offset: int = 0) -> list[dict]`**
- SELECT * FROM events ORDER BY recorded_at DESC LIMIT ? OFFSET ?
- For each event, fetch its detections.
- Return list of event dicts with nested detections.

**Method: `async def close(self) -> None`**
- If `self.db` is not None, call `await self.db.close()` and set `self.db = None`.
- Log "EventStore connection closed" at INFO level.

Add module-level docstring explaining this is the single shared database interface for the system.

Import: `import asyncio`, `import aiosqlite`, `import io`, `import logging`, `from pathlib import Path`, `from PIL import Image`.
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && source venv/bin/activate && python -c "
import asyncio, os, tempfile
from event_store import EventStore

async def smoke():
    with tempfile.TemporaryDirectory() as td:
        db = os.path.join(td, 'test.db')
        thumbs = os.path.join(td, 'thumbs')
        store = EventStore(db, thumbs)
        await store.initialize()
        # Verify WAL mode
        async with store.db.execute('PRAGMA journal_mode') as c:
            row = await c.fetchone()
            assert row[0] == 'wal', f'WAL not active: {row[0]}'
        # Write event
        eid = await store.write_event(
            camera_id='front_door',
            recorded_at='2026-02-25T10:30:00',
            recording_id='rec_001',
            person_name='alice',
            face_confidence=0.85,
            face_distance=0.15,
            unlock_granted=True,
            door_action='unlocked',
            detections=[{'label':'person','confidence':0.95,'bbox_x1':10,'bbox_y1':20,'bbox_x2':100,'bbox_y2':200}],
        )
        assert eid == 1, f'Expected event_id 1, got {eid}'
        # Read event back
        ev = await store.get_event(1)
        assert ev is not None
        assert ev['person_name'] == 'alice'
        assert ev['face_distance'] == 0.15
        assert ev['unlock_granted'] == 1
        assert len(ev['detections']) == 1
        assert ev['detections'][0]['label'] == 'person'
        # Read recent
        recent = await store.get_recent_events(limit=5)
        assert len(recent) == 1
        await store.close()
        print('ALL SMOKE TESTS PASSED')

asyncio.run(smoke())
"</automated>
  </verify>
  <done>EventStore class exists with initialize(), write_event(), get_event(), get_recent_events(), save_thumbnail(), and close() methods. WAL mode confirmed active. Event with detections writes and reads back with all fields intact. Person name, face_confidence, face_distance, unlock_granted, and door_action all stored correctly.</done>
</task>

</tasks>

<verification>
1. `python -c "import aiosqlite; import aiofiles"` succeeds in venv
2. `Config.DB_PATH` and `Config.THUMBNAILS_DIR` exist with correct defaults
3. WAL mode verified via `PRAGMA journal_mode` returning "wal"
4. Event with full fields (camera_id, recorded_at, event_type, recording_id, person_name, face_confidence, face_distance, unlock_granted, door_action, thumbnail_path) writes and reads back correctly
5. Detections linked to event by event_id write and read back correctly
6. `thumbnails/` directory exists
</verification>

<success_criteria>
- EventStore.initialize() creates all 3 tables and 5 indexes without error
- WAL mode is active (PRAGMA journal_mode returns "wal")
- write_event() returns an integer event_id and the event is readable via get_event()
- Detections linked to an event are stored and retrievable
- save_thumbnail() produces a JPEG file in the thumbnails directory
- All DATA-01 through DATA-06 schema requirements are satisfied by column definitions
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
