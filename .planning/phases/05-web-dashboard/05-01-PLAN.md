---
phase: 05-web-dashboard
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - event_store.py
  - config.py
  - app.py
  - .env.example
autonomous: true
requirements: [DASH-04, DASH-06, DASH-07]

must_haves:
  truths:
    - "EventStore can return events filtered by date range and object type"
    - "EventStore can return today's event count"
    - "Config has DASHBOARD_USERNAME and DASHBOARD_PASSWORD fields"
    - "Config.validate() rejects empty DASHBOARD_PASSWORD"
    - "app.state.switchbot is exposed for dashboard lock status queries"
  artifacts:
    - path: "event_store.py"
      provides: "get_filtered_events() and get_today_event_count() methods"
      contains: "get_filtered_events"
    - path: "config.py"
      provides: "DASHBOARD_USERNAME and DASHBOARD_PASSWORD config fields"
      contains: "DASHBOARD_PASSWORD"
    - path: "app.py"
      provides: "app.state.switchbot exposed in lifespan"
      contains: "app.state.switchbot"
    - path: ".env.example"
      provides: "Dashboard auth env var documentation"
      contains: "DASHBOARD_USERNAME"
  key_links:
    - from: "event_store.py"
      to: "events table"
      via: "get_filtered_events SQL with parameterized WHERE clause"
      pattern: "get_filtered_events"
    - from: "config.py"
      to: "app.py"
      via: "DASHBOARD_PASSWORD used by verify_credentials in Phase 5 Plan 02"
      pattern: "DASHBOARD_PASSWORD"
    - from: "app.py"
      to: "switchbot_client.py"
      via: "app.state.switchbot = switchbot in lifespan"
      pattern: "app\\.state\\.switchbot"
---

<objective>
Add EventStore query methods, dashboard config fields, and app.py wiring needed by the dashboard router.

Purpose: The dashboard router (Plan 02) needs filtered event queries, today's event count, dashboard auth credentials in Config, and access to SwitchBotClient via app.state. This plan delivers all backend prerequisites so Plan 02 can focus purely on routes and templates.

Output: Updated event_store.py with get_filtered_events() and get_today_event_count(), updated config.py with DASHBOARD_USERNAME/DASHBOARD_PASSWORD, updated app.py exposing app.state.switchbot, updated .env.example.
</objective>

<execution_context>
@.planning/phases/05-web-dashboard/05-RESEARCH.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@event_store.py
@config.py
@app.py
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_filtered_events() and get_today_event_count() to EventStore</name>
  <files>event_store.py</files>
  <action>
Add two new async methods to the EventStore class in event_store.py, placed after the existing get_recent_events() method and before close():

**Method 1: get_today_event_count()**
```python
async def get_today_event_count(self) -> int:
    """Count events recorded today (UTC calendar day)."""
    async with self.db.execute(
        "SELECT COUNT(*) FROM events WHERE DATE(recorded_at) = DATE('now')"
    ) as cursor:
        row = await cursor.fetchone()
    return row[0] if row else 0
```

**Method 2: get_filtered_events(limit, offset, date_range, object_type)**
- Parameters: limit (int, default 20), offset (int, default 0), date_range (str: "today"|"7d"|"30d"|"all", default "all"), object_type (str: "person"|"dog"|"cat"|"car"|"package"|"all", default "all")
- Build a WHERE clause dynamically from literal SQL strings (not user input)
- date_range "today" -> `DATE(recorded_at) = DATE('now')`
- date_range "7d" -> `recorded_at >= datetime('now', '-7 days')`
- date_range "30d" -> `recorded_at >= datetime('now', '-30 days')`
- object_type != "all" -> `EXISTS (SELECT 1 FROM detections d WHERE d.event_id = events.id AND d.label = ?)` with object_type as parameterized `?` value
- Use parameterized queries for ALL user-supplied values (never interpolate object_type into SQL string)
- ORDER BY recorded_at DESC LIMIT ? OFFSET ?
- After fetching events, load detections for each event (same pattern as get_recent_events)
- Return list[dict] with nested "detections" list per event

CRITICAL: The f-string SQL construction is safe ONLY because where_clause fragments are literal strings. The object_type value is always passed via the params list as a `?` placeholder.
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && python -c "
import ast
tree = ast.parse(open('event_store.py').read())
cls = [n for n in ast.walk(tree) if isinstance(n, ast.ClassDef) and n.name == 'EventStore'][0]
methods = [n.name for n in cls.body if isinstance(n, (ast.AsyncFunctionDef, ast.FunctionDef))]
assert 'get_filtered_events' in methods, f'get_filtered_events not found in {methods}'
assert 'get_today_event_count' in methods, f'get_today_event_count not found in {methods}'
print('OK: both new methods found in EventStore')
"</automated>
    <manual>Verify that get_filtered_events uses parameterized queries (? placeholders) for object_type, not string interpolation</manual>
  </verify>
  <done>EventStore has get_filtered_events(limit, offset, date_range, object_type) and get_today_event_count() methods with parameterized SQL queries</done>
</task>

<task type="auto">
  <name>Task 2: Add dashboard config fields and expose switchbot on app.state</name>
  <files>config.py, app.py, .env.example</files>
  <action>
**config.py changes:**
1. Add after the TELEGRAM_CHAT_ID line (new section comment "# Web Dashboard (Phase 5)"):
   - `DASHBOARD_USERNAME: str = os.getenv("DASHBOARD_USERNAME", "admin")`
   - `DASHBOARD_PASSWORD: str = os.getenv("DASHBOARD_PASSWORD", "")`
2. In the `validate()` classmethod, add a check: if `not cls.DASHBOARD_PASSWORD`, append `"DASHBOARD_PASSWORD is required"` to errors list. This prevents running with empty password (which would match any empty-password Basic Auth attempt).

**app.py changes:**
1. After the existing `app.state.alerter = alerter` line (line 111), add: `app.state.switchbot = switchbot`
   - This exposes the SwitchBotClient instance so the dashboard summary route can call get_lock_status() via run_in_executor.

**.env.example changes:**
1. Add a new section at the bottom:
```
# Web Dashboard (Phase 5)
DASHBOARD_USERNAME=admin
DASHBOARD_PASSWORD=changeme
```

Do NOT modify any other lines in these files. The changes are additive only.
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && python -c "
from config import Config
assert hasattr(Config, 'DASHBOARD_USERNAME'), 'DASHBOARD_USERNAME missing'
assert hasattr(Config, 'DASHBOARD_PASSWORD'), 'DASHBOARD_PASSWORD missing'
assert Config.DASHBOARD_USERNAME == 'admin', f'Default username wrong: {Config.DASHBOARD_USERNAME}'
# Validate that empty password is caught
errors = Config.validate()
found = any('DASHBOARD_PASSWORD' in e for e in errors)
print(f'Config fields present, empty password validation: {found}')
# Check app.py has switchbot on app.state
import ast
tree = ast.parse(open('app.py').read())
src = open('app.py').read()
assert 'app.state.switchbot' in src, 'app.state.switchbot not found in app.py'
print('OK: app.state.switchbot found in app.py')
"</automated>
  </verify>
  <done>Config has DASHBOARD_USERNAME and DASHBOARD_PASSWORD with empty-password validation. app.py exposes app.state.switchbot in lifespan. .env.example documents the new env vars.</done>
</task>

</tasks>

<verification>
All backend prerequisites for the dashboard router are in place:
1. EventStore has filtered query and today-count methods
2. Config has dashboard auth credentials
3. app.state exposes store, alerter, AND switchbot
4. .env.example documents all new env vars
5. Existing tests still pass: `cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && python -m pytest tests/ -x -q`
</verification>

<success_criteria>
- get_filtered_events() accepts date_range and object_type params with parameterized SQL
- get_today_event_count() returns integer count using DATE('now')
- Config.DASHBOARD_PASSWORD defaults to "" and validate() rejects it
- app.state.switchbot is set in lifespan alongside store and alerter
- All 52 existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-web-dashboard/05-01-SUMMARY.md`
</output>
