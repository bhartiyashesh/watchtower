---
phase: 03-pipeline-integration
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - config.py
  - .env.example
  - ring_client.py
  - main.py
  - app.py
autonomous: true
requirements: [PIPE-01, PIPE-02, PIPE-03, PIPE-04]

must_haves:
  truths:
    - "FastAPI app starts with uvicorn and Ring polling runs as asyncio.Task inside lifespan"
    - "Every motion event flows through YOLO detection, face recognition on person crop, EventStore write, and thumbnail save"
    - "Face match triggers SwitchBot unlock via executor with cooldown preserved"
    - "camera_id is populated on every EventStore write call"
    - "No asyncio.run() exists in main.py or app.py"
  artifacts:
    - path: "app.py"
      provides: "FastAPI application with lifespan context manager"
      min_lines: 60
      contains: "asynccontextmanager"
    - path: "main.py"
      provides: "polling_loop() async function with full pipeline"
      min_lines: 80
      contains: "async def polling_loop"
    - path: "config.py"
      provides: "CAMERA_ID, FASTAPI_HOST, FASTAPI_PORT config fields"
      contains: "CAMERA_ID"
    - path: "ring_client.py"
      provides: "wait_for_event returning (recording_id, kind) tuple"
      contains: "tuple[int, str]"
    - path: "requirements.txt"
      provides: "fastapi[standard] dependency"
      contains: "fastapi"
  key_links:
    - from: "app.py"
      to: "main.py"
      via: "import polling_loop; asyncio.create_task(polling_loop(...))"
      pattern: "create_task.*polling_loop"
    - from: "main.py"
      to: "object_detector.py"
      via: "await detector.detect(frame)"
      pattern: "detector\\.detect"
    - from: "main.py"
      to: "event_store.py"
      via: "await store.write_event(camera_id=Config.CAMERA_ID, ...)"
      pattern: "store\\.write_event"
    - from: "main.py"
      to: "face_recognizer.py"
      via: "await loop.run_in_executor(None, recognizer.identify, person_crop)"
      pattern: "run_in_executor.*recognizer\\.identify"
    - from: "main.py"
      to: "switchbot_client.py"
      via: "await loop.run_in_executor(None, switchbot.unlock)"
      pattern: "run_in_executor.*switchbot\\.unlock"
---

<objective>
Wire the full motion event pipeline end-to-end: FastAPI lifespan starts the Ring polling loop as an asyncio.Task, and each event flows through YOLO detection, face recognition on the person crop, EventStore persistence, and SwitchBot unlock — with camera_id populated on every write.

Purpose: This is the core integration milestone. Phase 1 (EventStore) and Phase 2 (ObjectDetector) are standalone modules. This plan wires them into the existing Ring -> FaceRecognizer -> SwitchBot pipeline so every motion event produces a persistent, structured record.

Output: `app.py` (new FastAPI entry point), restructured `main.py` (polling_loop function), updated `ring_client.py` (tuple return), updated `config.py` (3 new fields), updated `requirements.txt` (fastapi[standard]).
</objective>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-pipeline-integration/03-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@.planning/phases/02-object-detection/02-01-SUMMARY.md

Source files to modify:
@main.py
@ring_client.py
@config.py
@requirements.txt
@.env.example

Dependencies (read-only, do NOT modify):
@event_store.py
@object_detector.py
@face_recognizer.py
@switchbot_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install FastAPI, update config and ring_client return signature</name>
  <files>requirements.txt, config.py, .env.example, ring_client.py</files>
  <action>
1. Add `fastapi[standard]>=0.115.0` to `requirements.txt` (after the ultralytics line). Run `pip install "fastapi[standard]"` in the project venv. Run `pip check` to confirm no broken requirements.

2. Add three new fields to `config.py` Config class (after the YOLO_MODEL_PATH line):
```python
# Pipeline (Phase 3)
CAMERA_ID: str = os.getenv("CAMERA_ID", "front_door")
FASTAPI_HOST: str = os.getenv("FASTAPI_HOST", "127.0.0.1")
FASTAPI_PORT: int = int(os.getenv("FASTAPI_PORT", "8000"))
```
Note: Default host is `127.0.0.1` (not `0.0.0.0`) because Phase 3 has no auth. Phase 5 enables external binding after adding HTTP Basic Auth.

3. Add the three new env vars to `.env.example` with comments:
```
# Pipeline Integration (Phase 3)
CAMERA_ID=front_door
FASTAPI_HOST=127.0.0.1
FASTAPI_PORT=8000
```

4. Modify `ring_client.py` `wait_for_event()` return signature from `int | None` to `tuple[int, str] | None`. Change the return statement at line 106 from `return latest["id"]` to:
```python
kind = latest.get("kind", "motion")
return latest["id"], kind
```
Leave all other methods unchanged. The method now returns `(recording_id, kind)` or `None`. This avoids hardcoding `event_type="motion"` downstream.
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && source venv/bin/activate && python -c "from fastapi import FastAPI; from config import Config; assert Config.CAMERA_ID == 'front_door'; assert Config.FASTAPI_HOST == '127.0.0.1'; assert Config.FASTAPI_PORT == 8000; print('Config OK')" && pip check | tail -1</automated>
    <manual>Confirm requirements.txt has fastapi[standard], config.py has 3 new fields, ring_client.py returns tuple</manual>
  </verify>
  <done>fastapi importable, Config has CAMERA_ID/FASTAPI_HOST/FASTAPI_PORT, ring_client.wait_for_event returns tuple, pip check clean</done>
</task>

<task type="auto">
  <name>Task 2: Create app.py and restructure main.py with full pipeline</name>
  <files>app.py, main.py</files>
  <action>
**Create `app.py`** (new file) — the FastAPI application entry point that replaces `asyncio.run(main())`.

Structure:
- Import `asynccontextmanager` from contextlib, `asyncio`, `logging`, `uvicorn`, `FastAPI`
- Import all service classes: `Config`, `RingClient`, `FaceRecognizer`, `SwitchBotClient`, `ObjectDetector`, `EventStore`
- Import `polling_loop` from `main`
- Configure logging at module level (same format as current main.py): `logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s", datefmt="%Y-%m-%d %H:%M:%S")`

`@asynccontextmanager async def lifespan(app: FastAPI)`:
- Validate config via `Config.validate()`; if errors, log each and raise `RuntimeError`
- Initialize `EventStore(Config.DB_PATH, Config.THUMBNAILS_DIR)` and `await store.initialize()`
- Create `ObjectDetector(Config.YOLO_MODEL_PATH)`
- Create `FaceRecognizer(Config.KNOWN_FACES_DIR, Config.FACE_MATCH_TOLERANCE)`; log warning if `known_encodings` is empty but do NOT exit (allow dashboard to run without face recognition)
- Create `SwitchBotClient(Config.SWITCHBOT_TOKEN, Config.SWITCHBOT_SECRET, Config.SWITCHBOT_DEVICE_ID)`
- Create `RingClient(Config.RING_USERNAME, Config.RING_PASSWORD)` and `await ring.authenticate()`
- Start polling: `polling_task = asyncio.create_task(polling_loop(ring, recognizer, switchbot, detector, store))`
- Expose `store` on `app.state.store = store` (for Phase 5 dashboard routes)
- `yield`
- Graceful shutdown: `polling_task.cancel()`, wrap `await polling_task` in try/except `asyncio.CancelledError: pass`
- `detector.shutdown()`
- `await store.close()`
- `await ring.stop()`

Create the app: `app = FastAPI(lifespan=lifespan, title="Smart Lock System")`

Add a health check route:
```python
@app.get("/health")
async def health():
    return {"status": "ok"}
```

Entry point:
```python
if __name__ == "__main__":
    uvicorn.run("app:app", host=Config.FASTAPI_HOST, port=Config.FASTAPI_PORT, log_level="info")
```

CRITICAL: There must be NO `asyncio.run()` call anywhere in `app.py`. uvicorn owns the event loop.

---

**Restructure `main.py`** — convert from a standalone script to a module exporting `polling_loop()`.

Remove:
- The `if __name__ == "__main__": asyncio.run(main())` block at the bottom
- The `async def main()` function
- Component initialization code (moved to app.py lifespan)
- Config validation (moved to app.py lifespan)

Keep:
- All imports needed for the polling loop
- `logging.basicConfig` setup (keep for when main.py is imported; app.py also configures it)

Add new imports:
```python
import datetime
from object_detector import ObjectDetector, crop_person_bbox, detections_to_dicts
from event_store import EventStore
```

Create `async def polling_loop(ring, recognizer, switchbot, detector, store)`:
- Takes all 5 service instances as parameters (injected by app.py lifespan)
- Tracks `last_unlock_time: float = 0` as local state
- Implements the full pipeline per the research doc Pattern 2:

Per-event flow:
1. `result = await ring.wait_for_event(Config.POLL_INTERVAL)` — returns `(recording_id, kind)` or `None`
2. If `None`: `await asyncio.sleep(2); continue`
3. Unpack: `recording_id, event_kind = result`
4. Record `recorded_at = datetime.datetime.utcnow().isoformat()`
5. Cooldown check: if `time.time() - last_unlock_time < Config.UNLOCK_COOLDOWN`, log and continue
6. `frame = await ring.capture_frame(recording_id)` — if None, log warning and continue
7. `thumbnail_path = store.save_thumbnail(frame, recorded_at)` — synchronous, before DB write
8. `detections = await detector.detect(frame)` — async via ThreadPoolExecutor
9. `detection_dicts = detections_to_dicts(detections)`
10. Face recognition on YOLO person crop:
    - Filter person detections: `person_detections = [d for d in detections if d.label == "person"]`
    - If person_detections: pick highest confidence, call `crop_person_bbox(frame, best_person)`
    - If crop is not None: `matched_name = await loop.run_in_executor(None, recognizer.identify, person_crop)`
    - If crop is None: fall back to full frame via executor
    - If no person_detections: `matched_name = None`
    - Set `face_confidence = None` and `face_distance = None` (FaceRecognizer.identify() returns name only; Phase 3 research recommendation is to store None for these fields)
11. Determine door action:
    - If `matched_name` is not None: dispatch `switchbot.unlock()` via executor (`await loop.run_in_executor(None, switchbot.unlock)`), update `last_unlock_time`, set `unlock_granted = True`, `door_action = "unlocked"`
    - If unlock fails: `unlock_granted = False`, `door_action = "none"`, log error
    - If no match: `unlock_granted = False`, `door_action = "none"`
12. Persist event: `event_id = await store.write_event(camera_id=Config.CAMERA_ID, recorded_at=recorded_at, recording_id=str(recording_id), event_type=event_kind, person_name=matched_name, face_confidence=face_confidence, face_distance=face_distance, unlock_granted=unlock_granted, door_action=door_action, thumbnail_path=thumbnail_path, detections=detection_dicts)`
13. Log: `logger.info(f"Event persisted: event_id={event_id}")`

Exception handling:
- `except asyncio.CancelledError:` — log "Polling loop cancelled" and `raise` (CRITICAL: must re-raise for clean shutdown)
- `except Exception as exc:` — log exception, `await asyncio.sleep(5)` and continue

CRITICAL anti-patterns to avoid:
- Do NOT call `recognizer.identify()` directly — always via `loop.run_in_executor(None, ...)`
- Do NOT call `switchbot.unlock()` directly — always via `loop.run_in_executor(None, ...)`
- Do NOT catch `asyncio.CancelledError` in the `except Exception` block — it must be caught and re-raised BEFORE `except Exception`
- Do NOT add `asyncio.run()` anywhere in the file
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && source venv/bin/activate && python -c "
import ast, sys
# Verify app.py structure
with open('app.py') as f:
    tree = ast.parse(f.read())
names = [n.name for n in ast.walk(tree) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]
assert 'lifespan' in names, 'Missing lifespan function'
assert 'health' in names, 'Missing health endpoint'
# Verify no asyncio.run in app.py
with open('app.py') as f:
    src = f.read()
assert 'asyncio.run(' not in src, 'asyncio.run() found in app.py'

# Verify main.py structure
with open('main.py') as f:
    tree2 = ast.parse(f.read())
names2 = [n.name for n in ast.walk(tree2) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]
assert 'polling_loop' in names2, 'Missing polling_loop function'
with open('main.py') as f:
    src2 = f.read()
assert 'asyncio.run(' not in src2, 'asyncio.run() found in main.py'
assert 'run_in_executor' in src2, 'Missing run_in_executor for blocking calls'
assert 'detector.detect' in src2, 'Missing YOLO detection call'
assert 'store.write_event' in src2, 'Missing EventStore write call'
assert 'Config.CAMERA_ID' in src2, 'Missing CAMERA_ID in write_event call'
assert 'crop_person_bbox' in src2, 'Missing person crop for face recognition'
assert 'CancelledError' in src2, 'Missing CancelledError handling'
print('All structural checks PASSED')
"</automated>
    <manual>Review app.py lifespan initializes all services and starts polling_loop as asyncio.Task. Review main.py polling_loop dispatches FaceRecognizer and SwitchBot via run_in_executor.</manual>
  </verify>
  <done>app.py exists with FastAPI lifespan starting polling_loop as asyncio.Task, main.py exports polling_loop() with full YOLO->face->EventStore->SwitchBot pipeline, no asyncio.run() in either file, all blocking calls dispatched via run_in_executor, camera_id=Config.CAMERA_ID on every write_event call</done>
</task>

</tasks>

<verification>
1. `python -c "from app import app; print(app.title)"` prints "Smart Lock System"
2. `python -c "from main import polling_loop; import inspect; assert inspect.iscoroutinefunction(polling_loop)"` confirms polling_loop is async
3. `grep -c "asyncio.run" app.py main.py` returns 0 for both files
4. `grep "Config.CAMERA_ID" main.py` shows camera_id populated on every write_event call
5. `grep "run_in_executor" main.py` shows executor dispatch for both recognizer.identify and switchbot.unlock
6. `pip check` shows no broken requirements
</verification>

<success_criteria>
- fastapi[standard] installed and importable
- app.py creates FastAPI app with lifespan that initializes all services and starts polling_loop as asyncio.Task
- main.py exports polling_loop() that implements Ring capture -> YOLO detection -> face recognition (on person crop) -> EventStore write -> SwitchBot unlock (if matched) pipeline
- ring_client.py wait_for_event() returns (recording_id, kind) tuple
- config.py has CAMERA_ID, FASTAPI_HOST, FASTAPI_PORT
- No asyncio.run() in app.py or main.py
- All blocking calls (recognizer.identify, switchbot.unlock) dispatched via run_in_executor
- asyncio.CancelledError properly handled (caught and re-raised before except Exception)
</success_criteria>

<output>
After completion, create `.planning/phases/03-pipeline-integration/03-01-SUMMARY.md`
</output>
