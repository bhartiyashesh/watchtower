---
phase: 04-telegram-alerts
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - telegram_alerter.py
  - config.py
  - app.py
  - main.py
  - requirements.txt
autonomous: true
requirements: [TELE-01, TELE-02, TELE-03, TELE-04, TELE-05]

must_haves:
  truths:
    - "When an unrecognized person is detected, a Telegram message with photo and caption is sent"
    - "When a known person unlocks the door, a Telegram confirmation with photo and caption is sent"
    - "Duplicate alerts within 60 seconds are silently suppressed (coalescing)"
    - "AIORateLimiter proactively enforces Telegram rate limits without RetryAfter errors"
    - "Telegram unavailability does not prevent door unlock or event persistence"
  artifacts:
    - path: "telegram_alerter.py"
      provides: "TelegramAlerter class with alert_stranger, alert_unlock, coalescing, RetryAfter handling"
      exports: ["TelegramAlerter", "COALESCE_SECONDS"]
      min_lines: 70
    - path: "config.py"
      provides: "TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID config fields"
      contains: "TELEGRAM_BOT_TOKEN"
    - path: "app.py"
      provides: "TelegramAlerter initialized in lifespan, passed to polling_loop, shut down on exit"
      contains: "TelegramAlerter"
    - path: "main.py"
      provides: "Alert dispatch after EventStore write in polling_loop"
      contains: "alert_stranger"
  key_links:
    - from: "app.py"
      to: "telegram_alerter.py"
      via: "TelegramAlerter initialized in lifespan, passed to polling_loop"
      pattern: "alerter.*=.*TelegramAlerter"
    - from: "main.py"
      to: "telegram_alerter.py"
      via: "alerter.alert_stranger() and alerter.alert_unlock() called after store.write_event()"
      pattern: "alerter\\.alert_(stranger|unlock)"
    - from: "telegram_alerter.py"
      to: "telegram.ext.ExtBot"
      via: "ExtBot with AIORateLimiter for rate-limited Telegram API calls"
      pattern: "ExtBot.*rate_limiter.*AIORateLimiter"
    - from: "config.py"
      to: "app.py"
      via: "Config.TELEGRAM_BOT_TOKEN and Config.TELEGRAM_CHAT_ID read during lifespan init"
      pattern: "Config\\.TELEGRAM_BOT_TOKEN"

user_setup:
  - service: telegram
    why: "Sending real-time alerts to the homeowner's Telegram chat"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Create a bot via @BotFather on Telegram -> copy the token"
      - name: TELEGRAM_CHAT_ID
        source: "Send /start to your bot, then visit https://api.telegram.org/bot<token>/getUpdates to find your chat_id"
    dashboard_config:
      - task: "Create a Telegram bot via @BotFather"
        location: "Telegram app -> @BotFather -> /newbot"
      - task: "Send /start to the bot from your personal Telegram account"
        location: "Telegram app -> search for your bot -> /start"
---

<objective>
Create the TelegramAlerter module and wire it into the existing FastAPI lifespan and polling loop pipeline so that stranger-detected and unlock-confirmed events send photo alerts to a Telegram chat.

Purpose: Enables real-time doorstep notifications without requiring the homeowner to check the dashboard — satisfies all five TELE requirements in a single implementation pass.

Output: `telegram_alerter.py` (new module), updated `config.py`, `app.py`, `main.py`, and `requirements.txt`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/04-telegram-alerts/04-RESEARCH.md
@.planning/phases/03-pipeline-integration/03-01-SUMMARY.md
@app.py
@main.py
@config.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TelegramAlerter module and update config + requirements</name>
  <files>telegram_alerter.py, config.py, requirements.txt</files>
  <action>
**1. Install dependency:**
```bash
pip install "python-telegram-bot[rate-limiter]==22.6"
```
Then add `python-telegram-bot[rate-limiter]==22.6` to `requirements.txt` after the `fastapi[standard]` line.

**2. Create `telegram_alerter.py`** with the following structure:

- Import `asyncio`, `logging`, `time`, `Path` from pathlib, `ExtBot` from `telegram.ext`, `AIORateLimiter` from `telegram.ext`, `RetryAfter` and `TelegramError` from `telegram.error`.
- Logger: `logging.getLogger("smart-lock.telegram")`
- Module constant: `COALESCE_SECONDS = 60`

- Class `TelegramAlerter`:
  - `__init__(self, token: str, chat_id: str | int) -> None`:
    - Create `self._bot = ExtBot(token=token, rate_limiter=AIORateLimiter(max_retries=1))`
    - Store `self._chat_id = chat_id`
    - Initialize `self._last_stranger_alert: float = 0.0` and `self._last_unlock_alert: float = 0.0`
    - Create `self._lock = asyncio.Lock()`

  - `async def initialize(self) -> None`:
    - Call `await self._bot.initialize()` to open HTTP connection pool.
    - Validate chat reachability: `await self._bot.get_chat(chat_id=self._chat_id)` wrapped in try/except TelegramError. Log success with chat info. On failure, log error but do NOT raise — Telegram unavailability must not prevent door unlock from working.

  - `async def shutdown(self) -> None`:
    - Call `await self._bot.shutdown()` to close HTTP connection pool.

  - `async def alert_stranger(self, thumbnail_path: str | None, caption: str) -> None`:
    - Acquire `self._lock` ONLY to check and update `self._last_stranger_alert` timestamp using `time.monotonic()`. If less than `COALESCE_SECONDS` have elapsed, log debug message and return early (suppressed). Otherwise, update the timestamp.
    - RELEASE the lock BEFORE calling `_send_photo()` — do NOT hold the lock across HTTP I/O (see research pitfall #2).
    - Call `await self._send_photo(thumbnail_path, caption)`.

  - `async def alert_unlock(self, thumbnail_path: str | None, caption: str) -> None`:
    - Same coalescing pattern as `alert_stranger` but using `self._last_unlock_alert`. Separate timestamps so stranger and unlock alerts do not suppress each other.

  - `async def _send_photo(self, thumbnail_path: str | None, caption: str) -> None`:
    - Retry loop with `range(2)` (first try + one retry on RetryAfter).
    - If `thumbnail_path` is not None and `Path(thumbnail_path).exists()`: open file in binary mode, call `await self._bot.send_photo(chat_id=self._chat_id, photo=photo, caption=caption)`. This sends photo + caption in a single Telegram message (TELE-03).
    - Else (thumbnail missing): fall back to `await self._bot.send_message(chat_id=self._chat_id, text=caption)`.
    - Catch `RetryAfter`: normalize `e.retry_after` (may be int or timedelta in PTB v22 — use `isinstance` check, call `.total_seconds()` if timedelta). Sleep for the wait duration, then continue to next iteration.
    - Catch `TelegramError`: log error and return — do NOT crash the pipeline.
    - On success: return immediately after send.

**3. Update `config.py`:**
- Add two new class variables after the `FASTAPI_PORT` line:
  ```python
  # Telegram Alerts (Phase 4)
  TELEGRAM_BOT_TOKEN: str = os.getenv("TELEGRAM_BOT_TOKEN", "")
  TELEGRAM_CHAT_ID: str = os.getenv("TELEGRAM_CHAT_ID", "")
  ```
- Do NOT add validation for TELEGRAM_BOT_TOKEN/TELEGRAM_CHAT_ID in `validate()`. These are intentionally optional — if empty, the alerter is simply not created (consistent with how FaceRecognizer handles missing face data per Phase 3 decision).
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && python -c "
from telegram_alerter import TelegramAlerter, COALESCE_SECONDS
from config import Config
assert hasattr(TelegramAlerter, 'initialize'), 'Missing initialize method'
assert hasattr(TelegramAlerter, 'shutdown'), 'Missing shutdown method'
assert hasattr(TelegramAlerter, 'alert_stranger'), 'Missing alert_stranger method'
assert hasattr(TelegramAlerter, 'alert_unlock'), 'Missing alert_unlock method'
assert COALESCE_SECONDS == 60, 'COALESCE_SECONDS must be 60'
assert hasattr(Config, 'TELEGRAM_BOT_TOKEN'), 'Missing TELEGRAM_BOT_TOKEN in Config'
assert hasattr(Config, 'TELEGRAM_CHAT_ID'), 'Missing TELEGRAM_CHAT_ID in Config'
print('OK: TelegramAlerter module and Config verified')
" && python -c "import ast; ast.parse(open('telegram_alerter.py').read()); print('OK: telegram_alerter.py parses')" && grep -q 'python-telegram-bot\[rate-limiter\]' requirements.txt && echo 'OK: requirements.txt updated' && grep -q 'ExtBot' telegram_alerter.py && echo 'OK: Uses ExtBot (not Bot)' && grep -q 'AIORateLimiter' telegram_alerter.py && echo 'OK: Uses AIORateLimiter'</automated>
    <manual>Review telegram_alerter.py for correct coalescing pattern (lock released before _send_photo), RetryAfter timedelta normalization, and graceful error handling.</manual>
  </verify>
  <done>telegram_alerter.py exists with TelegramAlerter class implementing alert_stranger, alert_unlock, 60-second coalescing per alert type, ExtBot with AIORateLimiter, RetryAfter retry, and graceful error handling. Config has TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID fields. requirements.txt includes python-telegram-bot[rate-limiter]==22.6.</done>
</task>

<task type="auto">
  <name>Task 2: Wire TelegramAlerter into FastAPI lifespan and polling loop</name>
  <files>app.py, main.py</files>
  <action>
**1. Update `app.py` lifespan:**

- Add imports at top: `from telegram_alerter import TelegramAlerter` and `from config import Config` (Config is already imported via other modules — verify and add if needed).
- In the lifespan function, AFTER the RingClient authentication block and BEFORE `asyncio.create_task(polling_loop(...))`:
  ```python
  # --- Initialize Telegram alerter (optional — graceful if token missing) ---
  alerter = None
  if Config.TELEGRAM_BOT_TOKEN and Config.TELEGRAM_CHAT_ID:
      logger.info("Initializing Telegram alerter...")
      alerter = TelegramAlerter(
          token=Config.TELEGRAM_BOT_TOKEN,
          chat_id=Config.TELEGRAM_CHAT_ID,
      )
      await alerter.initialize()
  else:
      logger.warning(
          "TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not set — "
          "Telegram alerts disabled"
      )
  ```
- Update the `polling_loop` call to pass `alerter` as a sixth argument:
  ```python
  polling_task = asyncio.create_task(
      polling_loop(ring, recognizer, switchbot, detector, store, alerter)
  )
  ```
- Expose alerter on app.state (for future use): `app.state.alerter = alerter`
- In the shutdown section, AFTER `polling_task.cancel()` and its CancelledError catch, BEFORE `detector.shutdown()`:
  ```python
  if alerter is not None:
      await alerter.shutdown()
  ```

**2. Update `main.py` polling_loop:**

- Update `polling_loop` function signature to accept `alerter=None` as a sixth parameter with default None:
  ```python
  async def polling_loop(ring, recognizer, switchbot, detector: ObjectDetector, store: EventStore, alerter=None):
  ```
- AFTER the `store.write_event()` call and its log line (`logger.info(f"Event persisted: event_id={event_id}")`), add the Telegram alert dispatch block:
  ```python
  # --- Send Telegram alert ---
  if alerter is not None:
      if matched_name is None and any(d["label"] == "person" for d in detection_dicts):
          caption = (
              f"Unknown person detected at the door\n"
              f"Objects: {', '.join(d['label'] for d in detection_dicts)}\n"
              f"Time: {recorded_at}"
          )
          await alerter.alert_stranger(thumbnail_path, caption)
      elif matched_name is not None and unlock_granted:
          caption = (
              f"Welcome home, {matched_name}!\n"
              f"Door unlocked at {recorded_at}"
          )
          await alerter.alert_unlock(thumbnail_path, caption)
  ```
- The alert fires AFTER EventStore write, which guarantees the thumbnail file already exists on disk (save_thumbnail is synchronous and runs before write_event — confirmed in Phase 3 pipeline order).
- Do NOT catch exceptions from the alerter here — TelegramAlerter._send_photo already handles all TelegramError exceptions internally. Any unexpected exception from the alerter should propagate to the existing except Exception handler in the polling loop.
  </action>
  <verify>
    <automated>cd /Users/yasheshbharti/Documents/experiments/Ring-Auth/files/smart-lock-system && python -c "
import ast
# Verify app.py parses and contains TelegramAlerter integration
with open('app.py') as f:
    source = f.read()
    tree = ast.parse(source)
assert 'TelegramAlerter' in source, 'app.py missing TelegramAlerter'
assert 'alerter.shutdown' in source or 'alerter.shutdown()' in source, 'app.py missing alerter shutdown'
assert 'app.state.alerter' in source, 'app.py missing app.state.alerter'
print('OK: app.py verified')

# Verify main.py parses and contains alert dispatch
with open('main.py') as f:
    source = f.read()
    tree = ast.parse(source)
assert 'alert_stranger' in source, 'main.py missing alert_stranger call'
assert 'alert_unlock' in source, 'main.py missing alert_unlock call'
assert 'alerter=None' in source or 'alerter = None' in source, 'main.py missing alerter parameter default'
print('OK: main.py verified')
" && echo 'OK: All integration points verified'</automated>
    <manual>Verify that app.py lifespan creates alerter conditionally (only if token+chat_id set), passes it to polling_loop, and shuts it down on exit. Verify main.py alert dispatch is positioned after store.write_event().</manual>
  </verify>
  <done>app.py lifespan initializes TelegramAlerter conditionally (only when TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID are set), passes alerter to polling_loop, exposes on app.state, and shuts down on exit. main.py polling_loop accepts alerter parameter with None default, dispatches alert_stranger when unrecognized person detected, dispatches alert_unlock when known person unlocks door, both after EventStore write.</done>
</task>

</tasks>

<verification>
1. `python -c "from telegram_alerter import TelegramAlerter"` succeeds (module imports cleanly)
2. `python -c "import ast; ast.parse(open('app.py').read()); ast.parse(open('main.py').read()); ast.parse(open('telegram_alerter.py').read()); print('All files parse')"` succeeds
3. `grep -c 'ExtBot' telegram_alerter.py` returns >= 1 (uses ExtBot, not Bot)
4. `grep -c 'AIORateLimiter' telegram_alerter.py` returns >= 1 (rate limiter wired)
5. `grep -c 'alert_stranger\|alert_unlock' main.py` returns >= 2 (both alert paths wired)
6. `grep -q 'python-telegram-bot\[rate-limiter\]' requirements.txt` succeeds (dependency declared)
7. No `asyncio.run` or `Application.run_polling` in any modified file
</verification>

<success_criteria>
- TelegramAlerter class exists with ExtBot + AIORateLimiter, 60-second coalescing, RetryAfter retry, graceful error handling
- Config has TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID (optional, not in validate())
- app.py creates alerter conditionally, wires into lifespan lifecycle (init + shutdown)
- main.py dispatches stranger and unlock alerts after EventStore write
- All modified files parse without syntax errors
- No calls to Application.run_polling() or asyncio.run() in new/modified code
</success_criteria>

<output>
After completion, create `.planning/phases/04-telegram-alerts/04-01-SUMMARY.md`
</output>
