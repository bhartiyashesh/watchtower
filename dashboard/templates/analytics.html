{% extends "base.html" %}
{% block title %}Analytics — WatchTower{% endblock %}
{% block content %}

{# ── Analytics-specific styles ── #}
<style>
    :root {
        --glow-blue: rgba(68, 136, 255, 0.3);
        --glow-cyan: rgba(68, 221, 204, 0.2);
    }

    .container { max-width: 1400px; }

    /* Stats bar */
    .analytics-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }
    .stat-glow {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 1.25rem 1.5rem;
        position: relative;
        overflow: hidden;
        transition: transform 0.2s, border-color 0.2s;
    }
    .stat-glow:hover {
        transform: translateY(-2px);
        border-color: rgba(68, 136, 255, 0.3);
    }
    .stat-glow::before {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0;
        height: 2px;
        background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
    }
    .stat-glow .stat-value { font-size: 2.5rem; }

    /* Chart containers */
    .chart-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 1.25rem;
        margin-bottom: 2rem;
    }
    .chart-card {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 1.25rem;
        position: relative;
        min-height: 500px;
    }
    .chart-card h3 {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 0.25rem;
    }
    .chart-card .chart-subtitle {
        font-size: 0.85rem;
        color: var(--text-secondary);
        opacity: 0.7;
        margin-bottom: 0.75rem;
    }
    .chart-card .chart-area { width: 100%; position: relative; }

    /* Range selector */
    .range-selector {
        display: flex;
        gap: 0.35rem;
    }
    .range-btn {
        padding: 0.35rem 0.85rem;
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        color: var(--text-secondary);
        font-size: 0.85rem;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.15s, color 0.15s, border-color 0.15s;
    }
    .range-btn:hover {
        background: var(--bg-card-hover);
        color: var(--text-primary);
    }
    .range-btn.active {
        background: var(--accent-blue);
        border-color: var(--accent-blue);
        color: #fff;
    }

    /* Loading spinner */
    .chart-spinner {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 200px;
    }
    .chart-spinner::after {
        content: '';
        width: 28px; height: 28px;
        border: 3px solid var(--border-color);
        border-top-color: var(--accent-blue);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Tooltip */
    .chart-tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(10, 10, 15, 0.92);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.6rem 0.9rem;
        font-size: 0.9rem;
        color: var(--text-primary);
        white-space: nowrap;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.15s;
    }

    /* Responsive */
    @media (max-width: 768px) {
        .chart-grid { grid-template-columns: 1fr; }
        .analytics-stats { grid-template-columns: repeat(2, 1fr); }
        .orb-container { height: 280px; }
    }
</style>

{# ── Page heading + range selector ── #}
<div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:0.75rem;margin-bottom:1.5rem;">
    <div>
        <h1 style="margin-bottom:0.25rem;">Analytics</h1>
        <p style="color:var(--text-secondary);font-size:0.9rem;margin:0;">
            Activity overview with weather correlation
            <span id="location-info" style="margin-left:0.5rem;color:var(--accent-cyan);"></span>
        </p>
    </div>
    <div class="range-selector" id="range-selector">
        <button data-days="7" class="range-btn">7 Days</button>
        <button data-days="14" class="range-btn">14 Days</button>
        <button data-days="30" class="range-btn active">30 Days</button>
        <button data-days="90" class="range-btn">90 Days</button>
    </div>
</div>

{# ── Stats bar ── #}
<div class="analytics-stats" id="stats-bar">
    <div class="stat-glow"><div class="stat-label">Total Events</div><div class="stat-value" id="stat-total">—</div></div>
    <div class="stat-glow"><div class="stat-label">Today</div><div class="stat-value" id="stat-today">—</div></div>
    <div class="stat-glow"><div class="stat-label">Strangers Detected</div><div class="stat-value" id="stat-strangers">—</div></div>
    <div class="stat-glow"><div class="stat-label">Door Unlocks</div><div class="stat-value" id="stat-unlocks">—</div></div>
    <div class="stat-glow"><div class="stat-label">Camera Battery</div><div class="stat-value" id="stat-battery">—</div><div class="stat-sub" id="stat-battery-bar"></div></div>
</div>

{# ── Chart grid ── #}
<div class="chart-grid">
    <div class="chart-card">
        <h3>Activity Heatmap</h3>
        <div class="chart-subtitle">Events by hour and day of week over the last 30 days</div>
        <div class="chart-area" id="chart-heatmap"><div class="chart-spinner"></div></div>
    </div>
    <div class="chart-card">
        <h3>Detection Breakdown</h3>
        <div class="chart-subtitle">What types of objects were detected (people, cars, animals, packages)</div>
        <div class="chart-area" id="chart-donut"><div class="chart-spinner"></div></div>
    </div>
    <div class="chart-card">
        <h3>30-Day Timeline</h3>
        <div class="chart-subtitle">Daily event count with temperature and rainfall overlay</div>
        <div class="chart-area" id="chart-timeline"><div class="chart-spinner"></div></div>
    </div>
    <div class="chart-card">
        <h3>Known vs Strangers</h3>
        <div class="chart-subtitle">Recognized faces compared to unidentified visitors each day</div>
        <div class="chart-area" id="chart-stacked"><div class="chart-spinner"></div></div>
    </div>
    <div class="chart-card">
        <h3>Peak Hours</h3>
        <div class="chart-subtitle">Which hours of the day see the most activity — yellow for daytime, blue for nighttime</div>
        <div class="chart-area" id="chart-clock"><div class="chart-spinner"></div></div>
    </div>
    <div class="chart-card">
        <h3>Weather Correlation</h3>
        <div class="chart-subtitle">Does temperature or rain affect how many events are detected?</div>
        <div class="chart-area" id="chart-weather"><div class="chart-spinner"></div></div>
    </div>
</div>

{# ── Shared tooltip ── #}
<div class="chart-tooltip" id="tooltip"></div>

{# ── D3.js ── #}
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<script type="module">
// ── Helpers ──
const API = '/dashboard/api';
const tooltip = document.getElementById('tooltip');

// Shared geolocation — requested once, reused by all weather charts
// Strategy: try browser geolocation first, then IP-based lookup, then config fallback
const locationEl = document.getElementById('location-info');
const geoLocation = (async () => {
    const fallback = { latitude: {{ config.ANALYTICS_LATITUDE }}, longitude: {{ config.ANALYTICS_LONGITUDE }} };

    // 1. Try browser geolocation API
    if (navigator.geolocation) {
        try {
            const pos = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    timeout: 15000, maximumAge: 300000, enableHighAccuracy: false
                });
            });
            // Reverse geocode to get city name
            try {
                const geo = await fetch(`https://ipapi.co/json/`);
                const geoData = await geo.json();
                locationEl.textContent = `Weather: ${geoData.city || 'your location'}`;
            } catch { locationEl.textContent = `Weather: ${pos.coords.latitude.toFixed(2)}, ${pos.coords.longitude.toFixed(2)}`; }
            return { latitude: pos.coords.latitude, longitude: pos.coords.longitude };
        } catch (e) {
            console.warn('[Analytics] Browser geolocation failed:', e.message || e.code);
        }
    }

    // 2. Fallback: IP-based geolocation (no permissions needed)
    try {
        const res = await fetch('https://ipapi.co/json/');
        const data = await res.json();
        if (data.latitude && data.longitude) {
            locationEl.textContent = `Weather: ${data.city || data.region || `${data.latitude}, ${data.longitude}`}`;
            return { latitude: data.latitude, longitude: data.longitude };
        }
    } catch (e) {
        console.warn('[Analytics] IP geolocation failed:', e);
    }

    // 3. Last resort: config defaults
    locationEl.textContent = 'Weather: default location';
    return fallback;
})();

function formatHour(h) {
    if (h === 0) return '12 AM';
    if (h < 12) return h + ' AM';
    if (h === 12) return '12 PM';
    return (h - 12) + ' PM';
}

async function fetchJSON(path) {
    const res = await fetch(`${API}${path}`, { credentials: 'include' });
    if (!res.ok) throw new Error(`API ${path}: ${res.status}`);
    return res.json();
}

function clearSpinner(el) {
    const sp = el.querySelector('.chart-spinner');
    if (sp) sp.remove();
}

function showTooltip(evt, html) {
    tooltip.innerHTML = html;
    tooltip.style.opacity = 1;
    tooltip.style.left = (evt.pageX + 12) + 'px';
    tooltip.style.top = (evt.pageY - 10) + 'px';
}
function hideTooltip() { tooltip.style.opacity = 0; }

const LABEL_COLORS = {
    person: '#4488ff', car: '#44cc88', dog: '#ff8844',
    cat: '#8844ff', package: '#ffcc44'
};
function labelColor(label) { return LABEL_COLORS[label] || '#888888'; }

// ── 1. Stats bar ──
fetchJSON('/stats').then(d => {
    document.getElementById('stat-total').textContent = (d.total_events ?? 0).toLocaleString();
    document.getElementById('stat-today').textContent = (d.today_count ?? 0).toLocaleString();
    document.getElementById('stat-strangers').textContent = (d.total_strangers ?? 0).toLocaleString();
    document.getElementById('stat-unlocks').textContent = (d.total_unlocks ?? 0).toLocaleString();
}).catch(() => {});

// ── 1b. Battery level ──
fetchJSON('/battery').then(d => {
    const el = document.getElementById('stat-battery');
    const bar = document.getElementById('stat-battery-bar');
    if (d.battery !== null) {
        el.textContent = d.battery + '%';
        const color = d.battery > 50 ? 'var(--accent-green)' : d.battery > 20 ? 'var(--accent-yellow)' : 'var(--accent-orange)';
        el.style.color = color;
        bar.innerHTML = `<div style="background:rgba(255,255,255,0.06);border-radius:4px;height:6px;margin-top:0.5rem;overflow:hidden"><div style="width:${d.battery}%;height:100%;background:${color};border-radius:4px"></div></div>`;
    } else {
        el.textContent = 'N/A';
    }
}).catch(() => {});

// ── Range selector ──
let currentDays = 30;
const chartIds = ['chart-heatmap', 'chart-donut', 'chart-timeline', 'chart-stacked', 'chart-clock', 'chart-weather'];

document.querySelectorAll('.range-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const days = parseInt(btn.dataset.days);
        if (days === currentDays) return;
        currentDays = days;
        document.querySelectorAll('.range-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        // Clear and reload all charts
        chartIds.forEach(id => {
            const el = document.getElementById(id);
            el.innerHTML = '<div class="chart-spinner"></div>';
        });
        loadCharts(days);
    });
});

function loadCharts(numDays) {

// Update subtitles to reflect selected range
document.querySelector('#chart-heatmap').closest('.chart-card').querySelector('.chart-subtitle').textContent =
    `Events by hour and day of week over the last ${numDays} days`;
document.querySelector('#chart-timeline').closest('.chart-card').querySelector('h3').textContent =
    `${numDays}-Day Timeline`;
document.querySelector('#chart-timeline').closest('.chart-card').querySelector('.chart-subtitle').textContent =
    `Daily event count with temperature and rainfall overlay`;
document.querySelector('#chart-stacked').closest('.chart-card').querySelector('.chart-subtitle').textContent =
    `Recognized faces compared to unidentified visitors — last ${numDays} days`;
document.querySelector('#chart-clock').closest('.chart-card').querySelector('.chart-subtitle').textContent =
    `Which hours see the most activity — last ${numDays} days`;
document.querySelector('#chart-weather').closest('.chart-card').querySelector('.chart-subtitle').textContent =
    `Temperature vs event count — last ${numDays} days`;

// ── 3. Activity Heatmap ──
fetchJSON(`/hourly-heatmap?days=${numDays}`).then(data => {
    const el = document.getElementById('chart-heatmap');
    clearSpinner(el);
    const margin = { top: 20, right: 20, bottom: 40, left: 50 };
    const width = el.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const hours = d3.range(24);

    // Convert UTC day/hour to local time
    const tzOffsetHours = -(new Date().getTimezoneOffset() / 60); // e.g. -5 for EST
    const localLookup = {};
    data.forEach(d => {
        let localHour = d.hour + tzOffsetHours;
        let localDay = d.day_of_week;
        if (localHour < 0) { localHour += 24; localDay = (localDay + 6) % 7; }
        else if (localHour >= 24) { localHour -= 24; localDay = (localDay + 1) % 7; }
        const key = `${localDay}-${localHour}`;
        localLookup[key] = (localLookup[key] || 0) + d.count;
    });

    const svg = d3.select(el).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const x = d3.scaleBand().domain(hours).range([0, width]).padding(0.05);
    const y = d3.scaleBand().domain(d3.range(7)).range([0, height]).padding(0.05);
    const maxCount = d3.max(Object.values(localLookup)) || 1;
    const color = d3.scaleSequential(d3.interpolateViridis).domain([0, maxCount]);

    // Draw cells for all 168 slots
    for (let day = 0; day < 7; day++) {
        for (let hour = 0; hour < 24; hour++) {
            const count = localLookup[`${day}-${hour}`] || 0;
            svg.append('rect')
                .attr('x', x(hour)).attr('y', y(day))
                .attr('width', x.bandwidth()).attr('height', y.bandwidth())
                .attr('rx', 2)
                .attr('fill', count > 0 ? color(count) : 'rgba(255,255,255,0.03)')
                .on('mouseover', (evt) => showTooltip(evt, `${days[day]} ${formatHour(hour)} — <b>${count}</b> events`))
                .on('mouseout', hideTooltip);
        }
    }

    // Axes
    svg.append('g').attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickValues([0, 4, 8, 12, 16, 20]).tickFormat(h => formatHour(h)))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.append('g').attr('transform', `translate(0,${height})`)
        .selectAll('line,path').attr('stroke', '#555');
    svg.append('g')
        .call(d3.axisLeft(y).tickFormat(i => days[i]))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.selectAll('.domain, .tick line').attr('stroke', '#555');

    // Color legend
    const legendWidth = 200;
    const legendHeight = 10;
    const legendX = width - legendWidth;
    const legendY = -14;

    const defs = svg.append('defs');
    const linearGrad = defs.append('linearGradient').attr('id', 'heatmap-legend-grad');
    const stops = 10;
    for (let i = 0; i <= stops; i++) {
        linearGrad.append('stop')
            .attr('offset', `${(i / stops) * 100}%`)
            .attr('stop-color', d3.interpolateViridis(i / stops));
    }

    svg.append('rect')
        .attr('x', legendX).attr('y', legendY)
        .attr('width', legendWidth).attr('height', legendHeight)
        .attr('rx', 3)
        .attr('fill', 'url(#heatmap-legend-grad)');
    svg.append('text')
        .attr('x', legendX - 6).attr('y', legendY + legendHeight / 2)
        .attr('text-anchor', 'end').attr('dominant-baseline', 'middle')
        .attr('fill', '#888').attr('font-size', '0.75rem')
        .text('Fewer');
    svg.append('text')
        .attr('x', legendX + legendWidth + 6).attr('y', legendY + legendHeight / 2)
        .attr('dominant-baseline', 'middle')
        .attr('fill', '#888').attr('font-size', '0.75rem')
        .text('More events');
}).catch(() => clearSpinner(document.getElementById('chart-heatmap')));

// ── 4. Detection Donut ──
fetchJSON(`/detection-breakdown?days=${numDays}`).then(data => {
    const el = document.getElementById('chart-donut');
    clearSpinner(el);
    if (!data.length) { el.innerHTML = '<p style="color:#666;text-align:center;padding:2rem;">No detections</p>'; return; }

    const size = Math.min(el.clientWidth, 380);
    const radius = size / 2;
    const svg = d3.select(el).append('svg')
        .attr('width', size).attr('height', size)
        .style('display', 'block').style('margin', '0 auto')
        .append('g').attr('transform', `translate(${radius},${radius})`);

    const pie = d3.pie().value(d => d.count).sort(null).padAngle(0.02);
    const arc = d3.arc().innerRadius(radius * 0.55).outerRadius(radius * 0.85);
    const labelArc = d3.arc().innerRadius(radius * 0.68).outerRadius(radius * 0.68);
    const total = d3.sum(data, d => d.count);

    svg.selectAll('path').data(pie(data)).join('path')
        .attr('fill', d => labelColor(d.data.label))
        .attr('opacity', 0.85)
        .on('mouseover', function(evt, d) {
            d3.select(this).attr('opacity', 1);
            showTooltip(evt, `<b>${d.data.label}</b>: ${d.data.count} (${Math.round(d.data.count / total * 100)}%)<br>Avg conf: ${(d.data.avg_confidence * 100).toFixed(1)}%`);
        })
        .on('mouseout', function() { d3.select(this).attr('opacity', 0.85); hideTooltip(); })
        .transition().duration(800).attrTween('d', function(d) {
            const i = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
            return t => arc(i(t));
        });

    // Percentage labels on arcs
    svg.selectAll('.arc-label').data(pie(data)).join('text')
        .attr('class', 'arc-label')
        .attr('transform', d => `translate(${labelArc.centroid(d)})`)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('fill', '#fff')
        .attr('font-size', '0.85rem')
        .attr('font-weight', '600')
        .text(d => {
            const pct = Math.round(d.data.count / total * 100);
            return pct >= 5 ? pct + '%' : '';
        });

    // Center total
    svg.append('text').attr('text-anchor', 'middle').attr('dy', '-0.1em')
        .attr('fill', '#e8e8ed').attr('font-size', '2rem').attr('font-weight', '700')
        .text(total);
    svg.append('text').attr('text-anchor', 'middle').attr('dy', '1.3em')
        .attr('fill', '#8888a0').attr('font-size', '0.85rem')
        .text('detections');

    // Legend
    const legend = d3.select(el).append('div').style('display', 'flex').style('flex-wrap', 'wrap')
        .style('gap', '0.75rem').style('justify-content', 'center').style('margin-top', '0.75rem');
    data.forEach(d => {
        legend.append('span').style('font-size', '0.9rem').style('color', '#aaa')
            .html(`<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${labelColor(d.label)};margin-right:5px;vertical-align:middle"></span>${d.label}`);
    });
}).catch(() => clearSpinner(document.getElementById('chart-donut')));

// ── 5. 30-Day Timeline with Weather ──
(async () => {
    const el = document.getElementById('chart-timeline');
    let timeline = [];
    try { timeline = await fetchJSON(`/daily-timeline?days=${numDays}`); } catch { clearSpinner(el); return; }
    clearSpinner(el);
    if (!timeline.length) { el.innerHTML = '<p style="color:#666;text-align:center;padding:2rem;">No data</p>'; return; }

    const margin = { top: 20, right: 50, bottom: 40, left: 50 };
    const width = el.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const svg = d3.select(el).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const parseDate = d3.timeParse('%Y-%m-%d');
    timeline.forEach(d => d._date = parseDate(d.date));

    const x = d3.scaleTime().domain(d3.extent(timeline, d => d._date)).range([0, width]);
    const y = d3.scaleLinear().domain([0, d3.max(timeline, d => d.count) * 1.2]).range([height, 0]);

    // Area
    const area = d3.area().x(d => x(d._date)).y0(height).y1(d => y(d.count)).curve(d3.curveMonotoneX);
    svg.append('path').datum(timeline).attr('d', area)
        .attr('fill', 'rgba(68,136,255,0.15)').attr('stroke', '#4488ff').attr('stroke-width', 1.5);

    // Dots
    svg.selectAll('circle').data(timeline).join('circle')
        .attr('cx', d => x(d._date)).attr('cy', d => y(d.count))
        .attr('r', 3).attr('fill', '#4488ff')
        .on('mouseover', (evt, d) => showTooltip(evt, `<b>${d.date}</b><br>${d.count} events`))
        .on('mouseout', hideTooltip);

    // Axes
    svg.append('g').attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(6).tickFormat(d3.timeFormat('%b %d')))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.append('g')
        .call(d3.axisLeft(y).ticks(5))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.selectAll('.domain, .tick line').attr('stroke', '#555');

    // Weather overlay
    try {
        const { latitude: weatherLat, longitude: weatherLon } = await geoLocation;

        const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${weatherLat}&longitude=${weatherLon}&daily=temperature_2m_max,precipitation_sum&past_days=${numDays}&timezone=auto&temperature_unit=fahrenheit`;
        const weatherRes = await fetch(weatherUrl);
        const weatherData = await weatherRes.json();

        if (weatherData.daily) {
            const temps = weatherData.daily.temperature_2m_max;
            const precip = weatherData.daily.precipitation_sum;
            const dates = weatherData.daily.time;

            const yTemp = d3.scaleLinear()
                .domain([d3.min(temps) - 2, d3.max(temps) + 2])
                .range([height, 0]);

            // Temperature line
            const tempLine = d3.line()
                .x((_, i) => x(parseDate(dates[i])))
                .y((t) => yTemp(t))
                .defined((_, i) => parseDate(dates[i]) !== null)
                .curve(d3.curveMonotoneX);

            svg.append('path').datum(temps).attr('d', tempLine)
                .attr('fill', 'none').attr('stroke', '#ff8844').attr('stroke-width', 1.5)
                .attr('stroke-dasharray', '4,3').attr('opacity', 0.7);

            // Rain markers
            dates.forEach((date, i) => {
                if (precip[i] > 0.5) {
                    const px = x(parseDate(date));
                    if (px >= 0 && px <= width) {
                        svg.append('circle')
                            .attr('cx', px).attr('cy', height - 8)
                            .attr('r', Math.min(precip[i], 8))
                            .attr('fill', 'rgba(68,221,204,0.4)').attr('stroke', '#44ddcc').attr('stroke-width', 0.5);
                    }
                }
            });

            // Right axis for temperature
            svg.append('g').attr('transform', `translate(${width},0)`)
                .call(d3.axisRight(yTemp).ticks(4).tickFormat(t => `${t}°F`))
                .selectAll('text').attr('fill', '#aa7744').style('font-size', '0.85rem');
        }
    } catch {}
})();

// ── 6. Known vs Strangers stacked bars ──
fetchJSON(`/daily-timeline?days=${numDays}`).then(data => {
    const el = document.getElementById('chart-stacked');
    clearSpinner(el);
    if (!data.length) { el.innerHTML = '<p style="color:#666;text-align:center;padding:2rem;">No data</p>'; return; }

    const margin = { top: 20, right: 20, bottom: 40, left: 50 };
    const width = el.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const svg = d3.select(el).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const parseDate = d3.timeParse('%Y-%m-%d');
    data.forEach(d => d._date = parseDate(d.date));

    const x = d3.scaleBand().domain(data.map(d => d.date)).range([0, width]).padding(0.3);
    const maxY = d3.max(data, d => (d.known || 0) + (d.strangers || 0));
    const y = d3.scaleLinear().domain([0, maxY * 1.1]).range([height, 0]);

    // Known bars (bottom)
    svg.selectAll('.bar-known').data(data).join('rect').attr('class', 'bar-known')
        .attr('x', d => x(d.date)).attr('width', x.bandwidth())
        .attr('y', d => y(d.known || 0)).attr('height', d => height - y(d.known || 0))
        .attr('fill', '#4488ff').attr('rx', 2)
        .on('mouseover', (evt, d) => showTooltip(evt, `<b>${d.date}</b><br>Known: ${d.known || 0}<br>Strangers: ${d.strangers || 0}`))
        .on('mouseout', hideTooltip);

    // Stranger bars (stacked on top)
    svg.selectAll('.bar-stranger').data(data).join('rect').attr('class', 'bar-stranger')
        .attr('x', d => x(d.date)).attr('width', x.bandwidth())
        .attr('y', d => y((d.known || 0) + (d.strangers || 0)))
        .attr('height', d => height - y(d.strangers || 0))
        .attr('fill', '#ff8844').attr('rx', 2).attr('opacity', 0.85)
        .on('mouseover', (evt, d) => showTooltip(evt, `<b>${d.date}</b><br>Known: ${d.known || 0}<br>Strangers: ${d.strangers || 0}`))
        .on('mouseout', hideTooltip);

    // Axes
    const tickEvery = Math.max(1, Math.floor(data.length / 6));
    svg.append('g').attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickValues(data.filter((_, i) => i % tickEvery === 0).map(d => d.date))
            .tickFormat(d => d.slice(5)))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.append('g')
        .call(d3.axisLeft(y).ticks(5))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.selectAll('.domain, .tick line').attr('stroke', '#555');

    // Legend
    const legend = d3.select(el).append('div')
        .style('display', 'flex').style('gap', '1rem').style('justify-content', 'center').style('margin-top', '0.5rem');
    [['Known', '#4488ff'], ['Strangers', '#ff8844']].forEach(([label, c]) => {
        legend.append('span').style('font-size', '0.9rem').style('color', '#aaa')
            .html(`<span style="display:inline-block;width:12px;height:12px;border-radius:2px;background:${c};margin-right:5px;vertical-align:middle"></span>${label}`);
    });
}).catch(() => clearSpinner(document.getElementById('chart-stacked')));

// ── 7. Peak Hours — Horizontal Bar Chart ──
fetchJSON(`/peak-hours?days=${numDays}`).then(data => {
    const el = document.getElementById('chart-clock');
    clearSpinner(el);
    if (!data.length) { el.innerHTML = '<p style="color:#666;text-align:center;padding:2rem;">No data</p>'; return; }

    // Fill all 24 hours (data may be sparse)
    const lookup = {};
    data.forEach(d => { lookup[d.hour] = d.count; });
    const full = d3.range(24).map(h => ({ hour: h, count: lookup[h] || 0 }));

    const margin = { top: 10, right: 30, bottom: 40, left: 70 };
    const width = el.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const svg = d3.select(el).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const maxC = d3.max(full, d => d.count) || 1;

    const y = d3.scaleBand().domain(full.map(d => d.hour)).range([0, height]).padding(0.15);
    const x = d3.scaleLinear().domain([0, maxC * 1.1]).range([0, width]);

    // Gridlines
    svg.selectAll('.grid-line').data(x.ticks(5)).join('line')
        .attr('class', 'grid-line')
        .attr('x1', d => x(d)).attr('x2', d => x(d))
        .attr('y1', 0).attr('y2', height)
        .attr('stroke', 'rgba(255,255,255,0.06)').attr('stroke-dasharray', '2,3');

    // Bars
    svg.selectAll('.bar').data(full).join('rect').attr('class', 'bar')
        .attr('x', 0)
        .attr('y', d => y(d.hour))
        .attr('width', d => x(d.count))
        .attr('height', y.bandwidth())
        .attr('rx', 3)
        .attr('fill', d => (d.hour >= 6 && d.hour < 18) ? '#ffcc44' : '#4488ff')
        .attr('opacity', 0.8)
        .on('mouseover', (evt, d) => {
            d3.select(evt.currentTarget).attr('opacity', 1);
            showTooltip(evt, `<b>${formatHour(d.hour)}</b> — ${d.count} events`);
        })
        .on('mouseout', (evt) => { d3.select(evt.currentTarget).attr('opacity', 0.8); hideTooltip(); });

    // Count labels at end of bars
    svg.selectAll('.bar-label').data(full).join('text')
        .attr('class', 'bar-label')
        .attr('x', d => x(d.count) + 6)
        .attr('y', d => y(d.hour) + y.bandwidth() / 2)
        .attr('dominant-baseline', 'middle')
        .attr('fill', '#888')
        .attr('font-size', '0.75rem')
        .text(d => d.count > 0 ? d.count : '');

    // Y-axis: human-readable hour labels
    svg.append('g')
        .call(d3.axisLeft(y).tickFormat(h => formatHour(h)))
        .selectAll('text').attr('fill', '#ccc').style('font-size', '0.85rem');

    // X-axis
    svg.append('g').attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(5))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.selectAll('.domain, .tick line').attr('stroke', '#555');

    // Legend
    const legend = d3.select(el).append('div')
        .style('display', 'flex').style('gap', '1rem').style('justify-content', 'center').style('margin-top', '0.5rem');
    [['Daytime (6 AM – 6 PM)', '#ffcc44'], ['Nighttime (6 PM – 6 AM)', '#4488ff']].forEach(([label, c]) => {
        legend.append('span').style('font-size', '0.9rem').style('color', '#aaa')
            .html(`<span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:${c};margin-right:5px;vertical-align:middle"></span>${label}`);
    });
}).catch(() => clearSpinner(document.getElementById('chart-clock')));

// ── 8. Weather Correlation Scatter ──
(async () => {
    const el = document.getElementById('chart-weather');
    let timeline = [];
    try { timeline = await fetchJSON(`/daily-timeline?days=${numDays}`); } catch { clearSpinner(el); return; }

    const { latitude: weatherLat, longitude: weatherLon } = await geoLocation;

    let weatherData;
    try {
        const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${weatherLat}&longitude=${weatherLon}&daily=temperature_2m_max,precipitation_sum&past_days=${numDays}&timezone=auto&temperature_unit=fahrenheit`;
        const res = await fetch(weatherUrl);
        weatherData = await res.json();
    } catch { clearSpinner(el); el.innerHTML = '<p style="color:#666;text-align:center;padding:2rem;">Weather unavailable</p>'; return; }

    clearSpinner(el);
    if (!weatherData.daily || !timeline.length) { el.innerHTML = '<p style="color:#666;text-align:center;padding:2rem;">No data</p>'; return; }

    // Merge on date
    const tlLookup = {};
    timeline.forEach(d => { tlLookup[d.date] = d; });
    const merged = weatherData.daily.time.map((date, i) => ({
        date,
        temp: weatherData.daily.temperature_2m_max[i],
        precip: weatherData.daily.precipitation_sum[i],
        count: (tlLookup[date] || {}).count || 0,
    })).filter(d => d.temp !== null);

    const margin = { top: 20, right: 20, bottom: 45, left: 50 };
    const width = el.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const svg = d3.select(el).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const x = d3.scaleLinear().domain(d3.extent(merged, d => d.temp)).nice().range([0, width]);
    const y = d3.scaleLinear().domain([0, d3.max(merged, d => d.count) * 1.2]).range([height, 0]);
    const rScale = d3.scaleSqrt().domain([0, d3.max(merged, d => d.count) || 1]).range([3, 12]);
    const pColor = d3.scaleSequential(d3.interpolateBlues).domain([0, d3.max(merged, d => d.precip) || 10]);

    svg.selectAll('circle').data(merged).join('circle')
        .attr('cx', d => x(d.temp)).attr('cy', d => y(d.count))
        .attr('r', d => rScale(d.count))
        .attr('fill', d => d.precip > 0.5 ? pColor(d.precip) : 'rgba(68,136,255,0.5)')
        .attr('stroke', '#4488ff').attr('stroke-width', 0.5).attr('opacity', 0.8)
        .on('mouseover', (evt, d) => showTooltip(evt, `<b>${d.date}</b><br>Temp: ${d.temp}°F<br>Events: ${d.count}<br>Rain: ${d.precip}mm`))
        .on('mouseout', hideTooltip);

    svg.append('g').attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(5).tickFormat(t => `${t}°F`))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.append('g')
        .call(d3.axisLeft(y).ticks(5))
        .selectAll('text').attr('fill', '#888').style('font-size', '0.85rem');
    svg.selectAll('.domain, .tick line').attr('stroke', '#555');

    // Axis labels
    svg.append('text').attr('x', width / 2).attr('y', height + 38)
        .attr('text-anchor', 'middle').attr('fill', '#888').attr('font-size', '0.85rem')
        .text('Temperature (°F)');
    svg.append('text').attr('transform', 'rotate(-90)')
        .attr('x', -height / 2).attr('y', -38)
        .attr('text-anchor', 'middle').attr('fill', '#888').attr('font-size', '0.85rem')
        .text('Events');
})();

} // end loadCharts

// Initial load
loadCharts(30);
</script>

{% endblock %}
